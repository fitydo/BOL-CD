name: ci

on:
  push:
    branches: [ main, master ]
  pull_request:

jobs:
  lint-test:
    name: Lint and Test (Python)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install ruff pytest

      - name: Ruff (lint)
        run: ruff check .

      - name: Pytest
        run: pytest -q

      - name: Schemathesis (ASGI fuzz tests)
        run: |
          pip install schemathesis
          schemathesis run api/openapi.yaml \
            --asgi-app=bolcd.api.app:app \
            --checks all \
            --hypothesis-deadline=None \
            --hypothesis-max-examples=50

  helm-lint:
    name: Helm Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm Lint Chart
        run: |
          if [ -d deploy/helm ]; then helm lint deploy/helm; else echo 'No helm chart'; fi

      - name: Install kubeconform
        run: |
          curl -sSL https://github.com/yannh/kubeconform/releases/download/v0.6.7/kubeconform-linux-amd64.tar.gz | sudo tar -xz -C /usr/local/bin kubeconform

      - name: Validate rendered manifests with kubeconform
        run: |
          if [ -d deploy/helm ]; then \
            helm template bolcd deploy/helm -f deploy/helm/values.yaml -f deploy/helm/values-prod.yaml \
              | kubeconform -strict -ignore-missing-schemas \
                -skip CustomResourceDefinition \
                -skip "Kustomization" \
                -skip "ExternalSecret" \
                -skip "SecretStore" \
                -skip "ClusterSecretStore" \
                -skip "ServiceMonitor" \
                -skip "PrometheusRule"; \
          else \
            echo 'No helm chart'; \
          fi

  docker-build:
    name: Build (and optionally push) Docker image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker login to GHCR
        if: github.event_name == 'push'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build (and push if on push) image
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/bol-cd"
          TAG="${GITHUB_SHA::7}"
          if [ -f Dockerfile ]; then \
            docker buildx build \
              --platform linux/amd64 \
              -t "$IMAGE:$TAG" -t "$IMAGE:latest" \
              --push=$([ "${{ github.event_name }}" = push ] && echo true || echo false) \
              . ; \
          else \
            echo 'No Dockerfile found, skipping build'; \
          fi

      - name: Install cosign
        if: github.event_name == 'push'
        uses: sigstore/cosign-installer@v3

      - name: Sign image with cosign (keyless)
        if: github.event_name == 'push'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/bol-cd"
          TAG="${GITHUB_SHA::7}"
          cosign sign --yes "$IMAGE:$TAG"
          cosign sign --yes "$IMAGE:latest"

      - name: Install syft (SBOM)
        uses: anchore/sbom-action/download-syft@v0.17.7

      - name: Generate SBOM (CycloneDX JSON)
        run: |
          syft packages . -o cyclonedx-json > sbom.json
          echo "SBOM generated at sbom.json"

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: sbom.json

      - name: Attach SBOM to image (cosign attach)
        if: github.event_name == 'push'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/bol-cd"
          TAG="${GITHUB_SHA::7}"
          cosign attach sbom --sbom sbom.json "$IMAGE:$TAG"

name: CI

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install deps
        run: |
          python -m pip install -U pip
          pip install -r requirements.txt
      - name: Lint (ruff)
        run: ruff check .
      - name: Test (pytest)
        run: pytest -q
      - name: Helm lint
        uses: azure/setup-helm@v4
      - name: Lint chart
        run: helm lint deploy/helm

name: ci
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install
        run: |
          pip install -r requirements.txt
          if [ -f requirements.lock ]; then pip install -r requirements.lock || true; fi
      - name: Unit & Property Tests
        env:
          PYTEST_DISABLE_PLUGIN_AUTOLOAD: '1'
        run: pytest -q
      - name: Lint
        run: ruff check .
      - name: Package
        run: python -m build || true
      - name: Generate SBOM (pip freeze)
        run: |
          pip freeze > sbom.txt
          echo "SBOM written to sbom.txt"
      - name: CycloneDX SBOM
        run: |
          pip install -q cyclonedx-bom || true
          cyclonedx-py --format xml -o sbom.xml || true
      - name: Vulnerability scan (pip-audit)
        run: |
          pip install -q pip-audit || true
          pip-audit -r requirements.txt -f json -o vuln.json || true
      - name: Acceptance gate (enforced)
        env:
          ACCEPT_ENFORCE: '1'
        run: |
          python scripts/acceptance_check.py
  perf-guard:
    runs-on: ubuntu-latest
    needs: build-and-test
    env:
      PERF_D: '100'
      PERF_N: '200000'
      PERF_RUNS: '3'
      PERF_EPS_FLOOR: '7000'
      PERF_P95_CEIL_MS: '30000'
      PERF_REG_EPS_DROP: '0.10'
      PERF_REG_P95_RISE: '0.15'
      PERF_BASELINE_PATH: 'configs/perf-baseline.json'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install
        run: |
          pip install -r requirements.txt
          if [ -f requirements.lock ]; then pip install -r requirements.lock || true; fi
      - name: Build package (editable)
        run: pip install -e .
      - name: Warmup bench
        run: |
          bolcd-bench --d $PERF_D --n $PERF_N --runs 1 --out bench-warmup.json
      - name: Run perf bench
        run: |
          bolcd-bench --d $PERF_D --n $PERF_N --runs $PERF_RUNS --out bench.json
      - name: Check performance floors & regression
        run: |
          python - << 'PY'
          import json, os, sys
          from pathlib import Path

          bench = json.load(open('bench.json','r',encoding='utf-8'))
          eps = float(bench['eps_mean'])
          p95 = float(bench['latency_ms_p95'])
          params = bench.get('params', {})

          eps_floor = float(os.environ.get('PERF_EPS_FLOOR', '10000'))
          p95_ceil = float(os.environ.get('PERF_P95_CEIL_MS', '500'))
          reg_eps_drop = float(os.environ.get('PERF_REG_EPS_DROP', '0.10'))
          reg_p95_rise = float(os.environ.get('PERF_REG_P95_RISE', '0.15'))
          baseline_path = Path(os.environ.get('PERF_BASELINE_PATH', 'configs/perf-baseline.json'))

          print(f"Measured: EPS_mean={eps:.1f}, p95_ms={p95:.1f}, params={params}")

          # Floors
          if eps < eps_floor:
            raise SystemExit(f"FAIL: EPS floor {eps_floor} not met (got {eps:.1f})")
          if p95 > p95_ceil:
            raise SystemExit(f"FAIL: p95 ceil {p95_ceil}ms exceeded (got {p95:.1f}ms)")

          # Regression vs baseline if present and params comparable
          if baseline_path.exists():
            base = json.load(open(baseline_path, 'r', encoding='utf-8'))
            b_eps = float(base.get('eps_mean', 0.0))
            b_p95 = float(base.get('latency_ms_p95', 1e9))
            b_params = base.get('params', {})
            comparable = (b_params.get('d') == params.get('d')) and (b_params.get('n') == params.get('n'))
            if comparable:
              min_eps = b_eps * (1.0 - reg_eps_drop)
              max_p95 = b_p95 * (1.0 + reg_p95_rise)
              print(f"Baseline: EPS_mean={b_eps:.1f}, p95_ms={b_p95:.1f}; allowed min_eps={min_eps:.1f}, max_p95={max_p95:.1f}")
              if eps < min_eps:
                raise SystemExit(f"FAIL: EPS regression beyond {reg_eps_drop*100:.0f}% (got {eps:.1f} < {min_eps:.1f})")
              if p95 > max_p95:
                raise SystemExit(f"FAIL: p95 regression beyond {reg_p95_rise*100:.0f}% (got {p95:.1f} > {max_p95:.1f})")
            else:
              print("Skipping regression check: params mismatch between current and baseline")
          else:
            print("No baseline found; skipping regression check")

          print("Perf guard passed")
          PY
